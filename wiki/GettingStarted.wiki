= Getting Started =

This quick start tutorial demonstrates how to use uimaFIT to define and set a configuration parameter in an analysis engine, run it, and generate a descriptor file for it.  The complete code for this example can be found *[http://code.google.com/p/uimafit/source/browse/trunk/uimaFIT-examples/src/main/java/org/uimafit/examples/getstarted here]*.  

== A simple analysis engine implementation ==

Here is the complete analysis engine implementation for this example.  

{{{
public class GetStartedQuickAE extends org.uimafit.component.JCasAnnotator_ImplBase {

	@ConfigurationParameter(name="stringParamName")
	private String stringParam;
	
	@Override
	public void process(JCas jCas) throws AnalysisEngineProcessException {
		System.out.println("Hello world!  Say 'hi' to "+stringParam);
	}
  }
}}}

The first thing to note is that the member variable 'stringParam' is annotated with @!ConfigurationParameter which tells uimaFIT that this is an analysis engine configuration parameter.  The second thing to note is the package name of the super class.  The initialize method of this super class calls:

{{{

org.uimafit.component.initialize.ConfigurationParameterInitializer.initializeConfigurationParameters(Object, UimaContext) 

}}}

which populates the configuration parameters with the appropriate contents of the !UimaContext.  If you do not want to extend uimaFIT's `JCasAnnotator_ImplBase`, then you can call this method directly in the initialize method of your analysis engine or any class that implements [http://uimafit.googlecode.com/svn/trunk/uimaFIT/apidocs/org/uimafit/factory/initializable/Initializable.html org.uimafit.factory.initializable.Initializable].  You can call this method for an instance of any class that has configuration parameters.

== running the analysis engine ==

The following lines of code demonstrate how to instantiate and run the analysis engine from a main method:

{{{
TypeSystemDescription typeSystemDescription = 
    TypeSystemDescriptionFactory.createTypeSystemDescription(new Class[0]);
JCas jCas = JCasFactory.createJCas(typeSystemDescription);
AnalysisEngine analysisEngine = 
    AnalysisEngineFactory.createPrimitive(GetStartedQuickAE.class, typeSystemDescription, "stringParamName", "uimaFIT");
analysisEngine.process(jCas);
}}}

Normally, you would instantiate a type system description with the classes corresponding to type system types or provide the name of your type system (e.g. "org.uimafit.examples.!TypeSystem.xml").  In a more involved example, we would probably instantiate a collection reader and run this analysis engine over a collection of documents.  Here, it suffices to simply create a JCas with our empty type system.  Line 3 instantiates the analysis engine using !AnalysisEngineFactory and sets the string parameter named "stringParamName" to the value "uimaFIT".  Running this simple program sends the following output to the console:

{{{
Hello world!  Say 'hi' to uimaFIT
}}}

== generate a descriptor file ==

The following lines of code demonstrate how a descriptor file can be generated using the class definition:

{{{
TypeSystemDescription typeSystemDescription = 
    TypeSystemDescriptionFactory.createTypeSystemDescription(new Class[0]);
AnalysisEngineDescription analysisEngineDescription = 
    AnalysisEngineFactory.createPrimitiveDescription(GetStartedQuickAE.class, typeSystemDescription, "stringParamName", "uimaFIT");
analysisEngineDescription.toXML(new FileOutputStream("GetStartedQuickAE.xml"));
}}}

If you open the resulting descriptor file you will see that the configuration parameter "stringParamName" is defined with the value set to "uimaFIT".  We could now instantiate an analysis engine using this descriptor file with a line of code like this:

{{{
AnalysisEngineFactory.createAnalysisEngine("GetStartedQuickAE");
}}}

But, of course, we really wouldn't want to do that now that we can instantiate analysis engines using the class definition as was done above!  

This page, of course, did not demonstrate every feature of uimaFIT which provides support for annotating external resources, creating aggregate engines, running pipelines, testing components, among others.