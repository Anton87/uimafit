= Context injection =

== Parameter injection ==

uimaFIT defines the @!ConfigurationParameter annotation which can be used to annotate the fields of an analysis engine or collection reader. The purpose of this annotation is twofold:

  * injection of parameters from the UIMA context into fields
  * declaration of parameter metadata (mandatory, default value, description) which can be used to generate XML descriptors

In a regular UIMA component, parameters need to be manually extracted from the UIMA context, typically requiring a type cast. 

{{{
class MyAnalysisEngine extends CasAnnotator_ImplBase {
  public static final String PARAM_SOURCE_DIRECTORY = "sourceDirectory";
  private File sourceDirectory;

  public void initialize(UimaContext context) throws ResourceInitializationException {
    sourceDirectory = new File((String) context.getConfigParameterValue(PARAM_SOURCE_DIRECTORY));
  }
}
}}}

The component has no way to declare a default value or to declare if a parameter is optional or mandatory. In addition, any documentation needs to be maintained in !JavaDoc and in the XML descriptor for the component.

With uimaFIT, all this information can be declared in the component.

{{{
class MyAnalysisEngine extends org.uimafit.component.CasAnnotator_ImplBase {
  public static final String PARAM_SOURCE_DIRECTORY = "sourceDirectory";
  @ConfigurationParameter(name=PARAM_SOURCE_DIRECTORY, mandatory=true, defaultValue=".", 
    description="Directory to read the data from")
  private File sourceDirectory;
}
}}}

Note, that it is no longer necessary to implement the initialize() method. uimaFIT takes care of locating the parameter "sourceDirectory" in the UIMA context. It recognizes that the File class has a String constructor and uses that to instantiate a new File object from the parameter. If a mandatory parameter is not specified in the context, uimaFIT will generate an exception.

The other information (defaultValue and description) are used when generating an UIMA component description from the class. It should be pointed out in particular, that uimaFIT does not make use of the defaultValue when injecting parameters into fields. For this reason, it is possible to have a parameter that is mandatory but does have a default value. The default value is used as a parameter value when a component description is generated via the uimaFIT factories unless a parameter is specified in the factory call. If a component description in created manually without specifying a value for a mandatory parameter, uimaFIT will generate an exception.

The parameter injection mechanism is implemented in the ConfigurationParameterInitializer class. uimaFIT provides several base classes that already come with an initialize() method using the initializer:

  * !CasAnnotator_ImplBase
  * !CasCollectionReader_ImplBase
  * !CasConsumer_ImplBase
  * !CasMultiplier_ImplBase
  * JCasAnnotator_ImplBase
  * JCasCollectionReader_ImplBase
  * JCasFlowController_ImplBase
  * JCasMultiplier_ImplBase
  * !Resource_ImplBase

The !ConfigurationParameterInitializer can also be used with shared resources:

{{{
class MySharedResourceObject implements SharedResourceObject {
  public static final String PARAM_VALUE = "Value";
  @ConfigurationParameter(name = PARAM_VALUE, mandatory = true)
  private String value;

  public void load(DataResource aData) throws ResourceInitializationException {
    ConfigurationParameterInitializer.initialize(this, aData);
  }
}
}}}

Fields that can be annotated with the @ConfigurationParameter annotation are any array or collection types of primitive types (int, boolean, float, double), any enum types, any types that define a constructor accepting a single String (e.g. File), as well as, fields of the types Pattern and Locale.

== Resource injection ==

UIMA external resources can be injected into fields annotated with @ExternalResource. With UIMA, the external resource needs to be extracted from the context manually:

{{{
class MyAnalysisEngine extends CasAnnotator_ImplBase {
  public static final String RES_MODEL = "model";
  private DataResource model;

  public void initialize(UimaContext context) throws ResourceInitializationException {
    configuredResource = (DataResource) getContext().getResourceObject(RES_MODEL);
  }
}
}}}

uimaFIT allows a component to declare if a resource is mandatory and takes care of the injection.

{{{
class MyAnalysisEngine extends CasAnnotator_ImplBase {
  public static final String RES_MODEL = "model";
  @ExternalResource(name=RES_MODEL)
  private DataResource model;
}
}}}

=== Locators ===

Normally, in UIMA an external resource needs to implement either SharedResourceObject or Resource. In order to inject arbitrary objects, uimaFIT has the concept of ExternalResourceLocator. When a resource implements this interface, not the resource itself is injected, but the method getResource() is called on the resource and the result is injected. The following example illustrates how to inject an object from JNDI into a UIMA component:

{{{
class MyAnalysisEngine2 extends JCasAnnotator_ImplBase {
  static final String RES_DICTIONARY = "dictionary";
  @ExternalResource(key = RES_DICTIONARY)
  Dictionary dictionary;
}

AnalysisEngineDescription desc = createPrimitiveDescription(MyAnalysisEngine2.class);
bindResource(desc, MyAnalysisEngine2.RES_DICTIONARY, JndiResourceLocator.class,
  JndiResourceLocator.PARAM_NAME, "dictionaries/german");
}}}

== Issues ==

There are several issues with the context injection as it is currently implemented in uimaFIT:

  * The field types supported by the parameter injection mechanism are not extensible. To address this, we imagine to support Java Bean PropertyEditors (Issue 79) 
  * Default parameters cannot be overwritten by sub-classes. (Issue 69)
  * No warning if the context contains a parameter that the component does not know (Issue 7)
  * Default names for parameters and resources should be the name of the annotated field (Issue 70, Issue 71)
  * Parameters and resources should be mandatory by default (Issue 72)
  * Logger should be injectable from context (Issue 80)

== Relation to other dependency injection frameworks ==

JSR 250 defines the @Resource annotation. This could be used as an alternative for @ConfigurationParameter and @ExternalResource, but it does not support all the information provided by the two and provides some that we do not need in UIMA.

|| @Resource           || @ConfigurationParameter || @ExternalResource ||
|| name                || name                    || key               ||
|| type                || --                      || api               ||
|| shareable           || --                      ||                   ||
|| mappedName          || --                      || --                ||
|| description         || description             || --                ||
|| authenticationType  || --                      || --                ||
|| --                  || mandatory               || mandatory         ||
|| --                  || defaultValue            || --                ||

The Spring Framework defines an annotation [http://static.springsource.org/spring/docs/2.0.x/api/org/springframework/beans/factory/annotation/Required.html @Required] which can probably be used in conjunction with @Resource to incidate that a value is mandatory (I didn't try this out, but I expect it should work). [http://camel.apache.org/maven/current/camel-core/apidocs/org/apache/camel/spi/Required.html Apache Camel] seems to define a similar annotation.

We do not know of any substitute for defaultValue. However, this information is not used during injection, only during descriptor generation. It may be sensible to have a separate annotation (like @Required for 'mandatory') if a JSR 250 compatible approach is desired.